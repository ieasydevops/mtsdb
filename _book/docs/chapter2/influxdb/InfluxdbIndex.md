# 时间序列索引概览 [Time Series Index (TSI)]


## 时间序列索引解决的问题

为了支持大规模的时间序列 -即 单时间序列高基数的数据存储，Influx 增加了时间序列索引。通过TSI的存储引擎，用户能够处理上百万的独立的时间序列。

这项工作代表了自infloxdata于2016年发布时间序列合并树（TSM）存储引擎以来数据库中最重要的技术进步。


## 背景信息

Influxdb 实际看上去，像两个数据库合并为一,一个时间序列数据存储 和一个对指标，标签，和元数据域的 倒排索引.

### 时间结构的聚合树（TSM）

时间结构合并树（TSM）引擎于2015年构建，并于2016年继续增强，旨在解决原始时间序列数据获得最大吞吐量、压缩和查询速度的问题。在TSI之前，反向索引是一种内存中的数据结构，它是在基于TSM中的数据启动数据库时构建的。这意味着，对于每个度量、标记键值对和字段名，内存中都有一个查找表来将这些元数据位映射到底层时间序列。对于具有大量短暂序列的用户，随着新时间序列的创建，内存利用率不断增加。而且，启动时间增加了，因为所有这些数据都必须在启动时加载到堆中。

### Time Series Index (TSI)

新的时间序列索引（TSI）将索引移动到内存映射到磁盘的文件上，这意味着我们让操作系统处理最近使用最少的（LRU）内存。与原始时间序列数据的TSM引擎非常相似，我们有一个预写日志，其中有一个内存结构，该结构在查询时与内存映射索引合并。后台例程不断运行，将索引压缩成越来越大的文件，以避免在查询时执行过多的索引合并。
在封面下，我们使用罗宾汉散列（Robin Hood Hashing）等技术来进行快速索引查找，使用HyperLogLog++来保存基数估计的草图。后者将使我们能够向查询语言添加一些内容，比如SHOW CARDINALITY查询。


### TSI 解决的问题以及遗留的问题


时间序列索引（TSI）解决的主要问题是短暂的时间序列。最常见的情况是，这发生在希望通过在标记中放置标识符来跟踪每个流程度量或每个容器度量的用例中。例如，Kubernetes的Heapster项目就是这样做的。对于不再适合写入或查询的序列，它们不会占用内存空间。


Heapster项目和类似的用例没有解决的问题是限制了SHOW查询返回的数据的范围。我们将在将来更新查询语言，以便按时间限制这些结果。我们也不能解决让所有这些系列的读写都很热的问题。对于这个问题，扩展集群是解决方案。我们将不得不继续优化查询语言和引擎，以处理大量系列。我们需要在语言中添加护栏和限制，并最终将溢出添加到磁盘查询处理中。这项工作将在infloxdb的每次释放中进行。