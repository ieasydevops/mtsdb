
# Druid 索引

## 概述

多维条件查询通常是时序数据库的一个硬需求,其性能好坏也是评价一个时序数据库是否优秀的一个重要指标。
通常来说,支持多维查询的有如下两种方式：

* 位图索引(Bitmap Index)
* 倒排索引(Inverted Index)


## Bitmap Index

### BitMap 的基本原理


### BitMap Index的 工作机制

#### 构建索引的五个问题

1. BitMap 索引何时构建,在内存中如何构建
2. BitMap 索引的压缩处理机制
3. BitMap 索引落盘机制
4. 查询时候,如何基于BitMap构建 Cursor
5. 如何基于 Cursor定位到数据

### 五个问题详解

##### Bitmap索引如何在内存中构建？

Druid数据实时写入节点采用LSM结构保证数据的写入性能。数据先写入内存,每隔10min（可配）会将内存中的数据persist到本地硬盘形成文件,然后会有一个线程再每隔1h（可配）将本地硬盘的多个文件合并成一个segment。

##### Bitmap索引构建时机

Bitmap索引是应该在数据写入的同时实时构建呢,还是应该在数据从内存persist到硬盘的时候批量构建 ？

实时构建会对数据写入吞吐量造成一定影响,实际测试下来发现写入性能会下降5%到15%,而且表维度越多,性能下降越明显。
而另一方面,如果是批量构建,那么内存中的数据实际上是没有索引的,这部分数据的检索方式必然与已经持久化到硬盘文件数据的检索方式完全不同：内存中的数据检索不走索引直接查数据,文件中的数据检索需要先走索引再查数据,在实际查询实现中需要分别处理。

Druid中Bitmap的构建时机采用的后者,即在数据从内存persist到硬盘的时候批量构建。


##### 维度列构建维度字典


维度字典最核心的是两个Map映射：valueToId和idToValue
构建字典就是为维度列的取值赋一个自增的Int值


##### 构建Bitmap索引

Druid中Bitmap索引是在内存数据异步persist到硬盘文件的时候构建的,那接下来就需要看看表中一行记录过来之后如何分别为每个维度列构建Bitmap索引。

* 一个关键的点:
    每个维度列实际上都会维护一个Bitmap数组:MutableBitmap[],数组大小为每个维度列的可取值多少（Cardinality）,比如Gender列只有Male和Female两个取值,Bitmap数组大小就为2。数组的第一个值为Male对应的位图数据,数组的第二个值为Female对应的位图数据。这里就有一个问题,为什么说数组的第一个值是Male对应的位图数据,而不是第二个值呢？这就是用到了上文中提到的维度字典,Male对应的维度字典值为0,就对应数组下标为0；Female对应的维度字典值为1,对应数据下标就为1。

以其中一行数据为例介绍构建Bitmap索引的过程：
    1. 首先会为每一行生成一个自增的rowNum
    2. 遍历所有维度列，分别为每个维度列构建相应的Bitmap数组
    * 针对某个纬度列的value值，首先在维度字典中根据value找到对应的id，这个id即是Bitmap数组的下标，根据这个下标找到该value对应的位图数据，即MutableBitmap[id]
    * 定位到位图数据之后，再将该位图下标为rowNum的bit位置为1


## Inverted Index









## 参考阅读

[高效压缩位图RoaringBitmap的原理与应用](https://www.jianshu.com/p/818ac4e90daf)
